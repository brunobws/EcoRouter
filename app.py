"""
EcoRouter - Sistema de Rotas Ecol√≥gicas
Backend em Flask para c√°lculo de economia de CO‚ÇÇ
"""

from flask import Flask, render_template, request, jsonify
import math

app = Flask(__name__)

def geocode_address(address):
    """
    Simula geocodifica√ß√£o de endere√ßo
    Em produ√ß√£o, usar Google Maps Geocoding API ou OpenRouteService
    
    Args:
        address (str): Endere√ßo para geocodificar
        
    Returns:
        dict: Coordenadas lat/lng
    """
    # Hash simples para simular coordenadas baseadas no endere√ßo
    hash_value = sum(ord(c) for c in address)
    lat = -23.5 + (hash_value % 100) / 1000
    lng = -46.6 + (hash_value % 200) / 1000
    
    return {'lat': lat, 'lng': lng}

def calculate_distance(lat1, lon1, lat2, lon2):
    """
    Calcula dist√¢ncia entre dois pontos usando a f√≥rmula de Haversine
    
    Args:
        lat1, lon1: Coordenadas do ponto 1
        lat2, lon2: Coordenadas do ponto 2
        
    Returns:
        float: Dist√¢ncia em quil√¥metros
    """
    R = 6371  # Raio da Terra em km
    
    # Converter para radianos
    lat1_rad = math.radians(lat1)
    lat2_rad = math.radians(lat2)
    delta_lat = math.radians(lat2 - lat1)
    delta_lon = math.radians(lon2 - lon1)
    
    # F√≥rmula de Haversine
    a = (math.sin(delta_lat / 2) ** 2 + 
         math.cos(lat1_rad) * math.cos(lat2_rad) * 
         math.sin(delta_lon / 2) ** 2)
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
    distance = R * c
    
    return distance

def calculate_emissions(distance_standard, distance_eco, frequency):
    """
    Calcula emiss√µes e economia de CO‚ÇÇ
    
    Args:
        distance_standard: Dist√¢ncia da rota padr√£o em km
        distance_eco: Dist√¢ncia da rota ecol√≥gica em km
        frequency: Frequ√™ncia semanal de deslocamento
        
    Returns:
        dict: Dados de emiss√µes e economia
    """
    # Fatores de emiss√£o (kg CO‚ÇÇ por km)
    EMISSION_STANDARD = 0.120  # Rota padr√£o com tr√¢nsito
    EMISSION_ECO = 0.095       # Rota eco com velocidade constante
    
    # C√°lculo anual (52 semanas)
    total_standard = distance_standard * EMISSION_STANDARD * frequency * 52
    total_eco = distance_eco * EMISSION_ECO * frequency * 52
    savings = total_standard - total_eco
    
    # Compara√ß√µes educativas
    trees_equivalent = round(savings / 21)  # ~21kg CO‚ÇÇ/√°rvore/ano
    km_car_equivalent = round(savings / 0.120)  # km n√£o dirigidos
    
    return {
        'total_standard': round(total_standard, 2),
        'total_eco': round(total_eco, 2),
        'savings': round(savings, 2),
        'trees_equivalent': trees_equivalent,
        'km_car_equivalent': km_car_equivalent
    }

def get_impact_message(savings):
    """
    Retorna mensagem motivacional baseada na economia
    
    Args:
        savings: Economia de CO‚ÇÇ em kg
        
    Returns:
        str: Mensagem motivacional
    """
    if savings > 500:
        return "Impacto extraordin√°rio! Voc√™ √© um verdadeiro her√≥i ambiental! üåü"
    elif savings > 200:
        return "Excelente contribui√ß√£o para o planeta! üåç"
    elif savings > 50:
        return "√ìtima escolha! Cada quilograma conta! üå±"
    else:
        return "Pequenas a√ß√µes fazem grande diferen√ßa! üíö"

@app.route('/')
def index():
    """P√°gina inicial do EcoRouter"""
    return render_template('index.html')

@app.route('/calculate', methods=['POST'])
def calculate():
    """
    Endpoint para calcular rota ecol√≥gica e economia de CO‚ÇÇ
    
    Returns:
        JSON com dados da rota e economia
    """
    try:
        # Receber dados do formul√°rio
        data = request.get_json()
        origin = data.get('origin', '').strip()
        destination = data.get('destination', '').strip()
        frequency = int(data.get('frequency', 0))
        
        # Valida√ß√µes
        if not origin or not destination:
            return jsonify({'error': 'Por favor, preencha origem e destino'}), 400
        
        if frequency < 1 or frequency > 7:
            return jsonify({'error': 'Frequ√™ncia deve ser entre 1 e 7 vezes por semana'}), 400
        
        # Geocodificar endere√ßos
        origin_coords = geocode_address(origin)
        dest_coords = geocode_address(destination)
        
        # Calcular dist√¢ncia da rota padr√£o
        distance_standard = calculate_distance(
            origin_coords['lat'], origin_coords['lng'],
            dest_coords['lat'], dest_coords['lng']
        )
        
        # Simular rota ecol√≥gica (8% maior, mas com menor emiss√£o)
        distance_eco = distance_standard * 1.08
        
        # Calcular emiss√µes
        emissions = calculate_emissions(distance_standard, distance_eco, frequency)
        
        # Mensagem de impacto
        impact_message = get_impact_message(emissions['savings'])
        
        # Preparar resposta
        result = {
            'origin': origin,
            'destination': destination,
            'origin_coords': origin_coords,
            'dest_coords': dest_coords,
            'distance_standard': round(distance_standard, 2),
            'distance_eco': round(distance_eco, 2),
            'frequency': frequency,
            'emissions': emissions,
            'impact_message': impact_message
        }
        
        return jsonify(result)
    
    except ValueError:
        return jsonify({'error': 'Frequ√™ncia deve ser um n√∫mero v√°lido'}), 400
    except Exception as e:
        return jsonify({'error': f'Erro ao calcular rota: {str(e)}'}), 500

if __name__ == '__main__':
    # Rodar servidor Flask em modo debug
    print("\n" + "="*60)
    print("üåç EcoRouter - Sistema de Rotas Ecol√≥gicas")
    print("="*60)
    print("üöÄ Servidor rodando em: http://127.0.0.1:5000")
    print("üíö Pressione Ctrl+C para parar o servidor")
    print("="*60 + "\n")
    
    app.run(debug=True, host='0.0.0.0', port=5000)